/**
 * xe-utils.js v3.0.0-beta.0
 * MIT License.
 * @preserve
 */
!(function (n, t) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : n.XEUtils = t() }(this, function () { 'use strict'; const n = 'yyyy-MM-dd HH:mm:ss'; const S = { treeOptions: { parentKey: 'parentId', key: 'id', children: 'children' }, formatDate: n + '.SSSZ', formatString: n, dateDiffRules: [['yyyy', 31536e6], ['MM', 2592e6], ['dd', 864e5], ['HH', 36e5], ['mm', 6e4], ['ss', 1e3], ['S', 0]] }; function r () {} function t (n, e) { const u = Object[n]; return function (t) { const r = []; if (t) { if (u) return u(t); ot(t, e > 1 ? function (n) { r.push(['' + n, t[n]]) } : function () { r.push(arguments[e]) }) } return r } } function e (e, u) { return function (n, t) { if (n) { if (typeof n === 'string' || wn(n)) return n[e] ? n[e](t) : u(n, t); for (const r in n) if (Mn(n, r) && t === n[r]) return r } return -1 } }r.v = 'v3', r.mixin = function () { mn(arguments, function (n) { ot(n, function (t, n) { r[n] = En(t) ? function () { const n = t.apply(r.$context, arguments); return r.$context = null, n } : t }) }) }, r.setup = function (n) { return B(S, n) }; const u = Object.prototype.toString; function i (t) { return function (n) { return '[object ' + t + ']' === u.call(n) } } function o (t) { return function (n) { return typeof n === t } } function a (o, a, f, c, l) { return function (n, t, r) { if (n && t) { if (o && n[o]) return n[o](t, r); if (a && wn(n)) { for (let e = 0, u = n.length; e < u; e++) if (!!t.call(r, n[e], e, n) === c) return [!0, !1, e, n[e]][f] } else for (const i in n) if (Mn(n, i) && !!t.call(r, n[i], i, n) === c) return [!0, !1, i, n[i]][f] } return l } } function f (u) { return function (n, t, r) { if (n && En(t)) { if (wn(n) || Tn(n)) return u(n, t, r); for (const e in n) if (Mn(n, e) && t.call(r, n[e], e, n)) return e } return -1 } } function c (o) { return function (r, e) { let u, i; return r && r.length ? (mn(r, function (n, t) { e && (n = En(e) ? e(n, t, r) : ft(n, e)), On(n) || !On(u) && !o(u, n) || (i = t, u = n) }), r[i]) : u } } function l (c, l) { return function (r, e) { let n; let t; const u = {}; const i = []; const o = this; const a = arguments; const f = a.length; if (!En(e)) { for (t = 1; t < f; t++)n = a[t], i.push.apply(i, wn(n) ? n : [n]); e = 0 } return ot(r, function (n, t) { ((e ? e.call(o, n, t, r) : Vn(i, function (n) { return n === t }) > -1) ? c : l) && (u[t] = n) }), u } } function s (r) { return function (n) { if (n) { const t = r(n); if (!isNaN(t)) return t } return 0 } } function h (o) { return function (n, t, r, e) { const u = r || {}; const i = u.children || 'children'; return o(null, n, t, e, [], [], i, u) } } function p (n, t) { return n === t } function g (t, r) { try { delete t[r] } catch (n) { t[r] = void 0 } } function v (r, e, u, i, n, t, o) { if (r === e) return !0; if (r && e && !Wn(r) && !Wn(e) && !Tn(r) && !Tn(e)) { if (In(r)) return u('' + r, '' + e, n, t, o); if (Cn(r) || Fn(r)) return u(+r, +e, n, t, o); let a; let f; let c; const l = wn(r); const s = wn(e); if (l || s ? l && s : r.constructor === e.constructor) return f = tt(r), c = tt(e), i && (a = i(r, e, n)), f.length === c.length && (Nn(a) ? en(f, function (n, t) { return n === c[t] && v(r[n], e[c[t]], u, i, l || s ? t : n, r, e) }) : !!a) } return u(r, e, n, t, o) } function d (n, t) { return T(bt(n)).replace(new RegExp('(\\d+.\\d{0,' + t + '}).*'), '$1') } function m (t) { const r = new RegExp('(?:' + tt(t).join('|') + ')', 'g'); return function (n) { return qt(n).replace(r, function (n) { return t[n] }) } } function b (n) { return n.getFullYear() } function D (n) { return n.getMonth() } function y (n) { return n.getTime() } function x (n) { return n ? n.splice && n.join ? n : ('' + n).split('.') : [] } function M () { return H ? H.origin || H.protocol + '//' + H.host : '' } function O (n) { return Date.UTC(n[0], n[1], n[2], n[3], n[4], n[5], n[6]) } function N (n) { return y((t = n, new Date(b(t), D(t), t.getDate()))); let t } function w () { return new Date() } function k (n, t) { const r = T(n); const e = T(t); const u = Math.pow(10, Math.max(E(r), E(e))); return (xt(n, u) + xt(t, u)) / u } function E (n) { return (n.split('.')[1] || '').length } function F (n, t) { const r = T(n); const e = T(t); const u = E(r); const i = E(e) - u; const o = i < 0; const a = Math.pow(10, o ? Math.abs(i) : i); return xt(r.replace('.', '') / e.replace('.', ''), o ? 1 / a : a) } function T (n) { if (('' + n).indexOf('e-') >= 0) { const t = n < 0; return (t ? '-' : '') + '0' + ('' + ((t ? Math.abs(n) : n) + 1)).substr(1) } return '' + n } const W = 'undefined'; const I = 'last'; const A = 'first'; const j = 864e5; const C = 7 * j; var H = typeof location === W ? 0 : location; const R = typeof window === W ? 0 : window; const Z = typeof document === W ? 0 : document; const z = encodeURIComponent; const L = decodeURIComponent; const $ = parseInt; const P = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;' }; const U = /(.+)?\[(\d+)\]$/; const Y = Object.assign; function q (t, n, r) { for (var e, u = n.length, i = 1; i < u; i++)e = n[i], mn(tt(n[i]), r ? function (n) { t[n] = gt(e[n], r) } : function (n) { t[n] = e[n] }); return t } var B = function (n) { if (n) { const t = arguments; if (!0 !== n) return Y ? Y.apply(Object, t) : q(n, t); if (t.length > 1) return q(n = wn(n[1]) ? [] : {}, t, !0) } return n }; const J = B; function K (r, e, u) { const i = {}; if (r) { if (!e) return r; En(e) || (e = Bt(e)), ot(r, function (n, t) { i[t] = e.call(u, n, t, r) }) } return i } function _ (n, t, r) { if (n) for (const e in n)Mn(n, e) && t.call(r, n[e], e, n) } function Q (t, r, e) { yn(tt(t), function (n) { r.call(e, t[n], n, t) }) } function X (n) { const t = []; return ot(n, function (n) { fn(t, n) || t.push(n) }), t } function G (n, t) { return Nn(n) ? 1 : Zn(n) ? Nn(t) ? -1 : 1 : n && n.localeCompare ? n.localeCompare(t) : t < n ? 1 : -1 } function V (u, i) { return function (n, t) { const r = n[u]; const e = t[u]; return r === e ? i ? i(n, t) : 0 : G(r, e) } } function nn (n, t, r) { if (n) { if (On(t)) return pn(n).sort(G); let e; let u = sn(n, function (n) { return { data: n } }); let i = (o = n, a = u, c = r, mn(f = wn(f = t) ? f : [f], function (r, e) { mn(a, En(r) ? function (n, t) { n[e] = r.call(c, n.data, t, o) } : function (n) { n[e] = ft(n.data, r) }) }), f).length; if (i) { for (;i >= 0;)e = V(i, e), i--; u = u.sort(e) } return sn(u, Bt('data')) } let o, a, f, c; return [] } function tn (n) { for (var t, r = [], e = rt(n), u = e.length - 1; u >= 0; u--)t = u > 0 ? mt(0, u) : 0, r.push(e[t]), e.splice(t, 1); return r } const rn = a('some', 1, 0, !0, !1); var en = a('every', 1, 1, !1, !0); function un (n, t, r) { const e = []; if (n) for (t = t || 0, r = r || n.length; t < r; t++)e.push(n[t]); return e } const on = a('find', 1, 3, !0); const an = a('', 0, 2, !0); function fn (n, t) { return Xn(n, t) !== -1 } function cn (n, t) { if (n.indexOf) return n.indexOf(t); for (let r = 0, e = n.length; r < e; r++) if (t === n[r]) return r } function ln (n, t) { if (n.lastIndexOf) return n.lastIndexOf(t); for (let r = n.length - 1; r >= 0; r--) if (t === n[r]) return r; return -1 } function sn (n, t, r) { const e = []; if (n && arguments.length > 1) { if (En(t) || (t = Bt(t)), n.map) return n.map(t, r); ot(n, function () { e.push(t.apply(r, arguments)) }) } return e } function hn (n) { let t; let r; let e; const u = []; if (n && n.length) for (t = 0, e = (r = St(n, function (n) { return n ? n.length : 0 })) ? r.length : 0; t < e; t++)u.push(sn(n, t)); return u } function pn (n) { return sn(n, function (n) { return n }) } function gn (n, t) { let r; let e = 0; if (wn(n) && wn(t)) { for (r = t.length; e < r; e++) if (!fn(n, t[e])) return !1; return !0 } return fn(n, t) } function vn (n, t) { for (var r, e = arguments, u = [], i = [], o = 2, a = e.length; o < a; o++)u.push(e[o]); if (wn(t)) { for (a = t.length - 1, o = 0; o < a; o++)i.push(t[o]); t = t[a] } return sn(n, function (n) { if (i.length && (n = (function (n, t) { for (var r = 0, e = t.length; n && r < e;)n = n[t[r++]]; return e && n ? n : 0 }(n, i))), (r = n[t] || t) && r.apply) return r.apply(n, u) }) } const dn = vn; function mn (n, t, r) { if (n) if (n.forEach)n.forEach(t, r); else for (let e = 0, u = n.length; e < u; e++)t.call(r, n[e], e, n) } function yn (n, t, r) { for (let e = n.length - 1; e >= 0; e--)t.call(r, n[e], e, n) } const Sn = h(function n (t, r, e, u, i, o, a, f) { let c, l, s, h, p, g; if (r) for (l = 0, s = r.length; l < s; l++) { if (c = r[l], h = i.concat(['' + l]), p = o.concat([c]), e.call(u, c, l, r, h, t, p)) return { index: l, item: c, path: h, items: r, parent: t, nodes: p }; if (a && c && (g = n(c, c[a], e, u, h.concat([a]), p, a, f))) return g } }); const bn = h(function r (e, u, i, o, a, f, c, l) { let s, h; ot(u, function (n, t) { s = a.concat(['' + t]), h = f.concat([n]), i.call(o, n, t, u, s, e, h), n && c && (s.push(c), r(n, n[c], i, o, s, h, c, l)) }) }); const Dn = h(function r (e, u, i, o, a, f, c, l) { let s; let h; let p; const g = l.mapChildren || c; return sn(u, function (n, t) { return s = a.concat(['' + t]), h = f.concat([n]), (p = i.call(o, n, t, u, s, e, h)) && n && c && n[c] && (p[g] = r(n, n[c], i, o, s, h, c, l)), p }) }); const xn = h(function (n, t, r, e, u, i, o, a) { return (function r (e, u, i, o, a, f, c, l, s) { let h; let p; let g; let v; let d; const m = []; const y = s.original; const S = s.mapChildren || l; return mn(i, function (n, t) { h = f.concat(['' + t]), p = c.concat([n]), v = e || o.call(a, n, t, i, h, u, p), d = l && n[l], (v || d) && (g = y ? n : B({}, n)), v || d ? (g[S] = r(v, n, n[l], o, a, h, p, l, s), (v || g[S].length) && m.push(g)) : v && m.push(g) }), m }(0, n, t, r, e, u, i, o, a)) }); function Mn (n, t) { return !(!n || !n.hasOwnProperty) && n.hasOwnProperty(t) } function On (n) { return Zn(n) || Nn(n) } var Nn = o(W); var wn = Array.isArray || i('Array'); const kn = function (n) { return !Zn(n) && !isNaN(n) && !wn(n) && n % 1 == 0 }; var En = o('function'); var Fn = o('boolean'); var Tn = o('string'); var Wn = o('number'); var In = i('RegExp'); const An = o('object'); function jn (n) { return !!n && n.constructor === Object } var Cn = i('Date'); const Hn = i('Error'); function Rn (n) { for (const t in n) return !1; return !0 } function Zn (n) { return n === null } const zn = typeof Symbol !== W; function Ln (n) { return zn && Symbol.isSymbol ? Symbol.isSymbol(n) : typeof n === 'symbol' } const $n = i('Arguments'); const Pn = typeof FormData !== W; const Un = typeof Map !== W; const Yn = typeof WeakMap !== W; const qn = typeof Set !== W; const Bn = typeof WeakSet !== W; function Jn (n) { let t; const r = n ? wt(n) : w(); return !!Cn(r) && ((t = r.getFullYear()) % 4 == 0 && (t % 100 != 0 || t % 400 == 0)) } function Kn (n, t) { return v(n, t, p) } let _n = 0; function Qn (n) { let t = 0; return Tn(n) || wn(n) ? n.length : (ot(n, function () { t++ }), t) } var Xn = e('indexOf', cn); const Gn = e('lastIndexOf', ln); var Vn = f(function (n, t, r) { for (let e = 0, u = n.length; e < u; e++) if (t.call(r, n[e], e, n)) return e; return -1 }); const nt = f(function (n, t, r) { for (let e = n.length - 1; e >= 0; e--) if (t.call(r, n[e], e, n)) return e; return -1 }); var tt = t('keys', 1); var rt = t('values', 0); const et = t('entries', 2); const ut = l(1, 0); const it = l(0, 1); function ot (n, t, r) { return n ? (wn(n) ? mn : _)(n, t, r) : n } function at (n, t, r) { return n ? (wn(n) ? yn : Q)(n, t, r) : n } function ft (n, t, r) { if (On(n)) return r; const e = (function (n, t) { if (n) { let r; let e; let u; let i = 0; if (n[t] || Mn(n, t)) return n[t]; if (e = x(t), u = e.length) for (r = n; i < u; i++) if (o = r, a = e[i], void 0, f = a ? a.match(U) : '', On(r = f ? f[1] ? o[f[1]] ? o[f[1]][f[2]] : void 0 : o[f[2]] : o[a])) return i === u - 1 ? r : void 0; return r } let o, a, f }(n, t)); return Nn(e) ? r : e } const ct = /(.+)\[(\d+)\]$/; function lt (n, t, r, e) { if (n[t]) return r && (n[t] = e), n[t]; let u; const i = t ? t.match(ct) : null; const o = r ? e : {}; return i ? (u = $(i[2]), n[i[1]] || (n[i[1]] = new Array(u + 1)), n[i[1]][u] = o) : n[t] = o, o } function st (r, e, u) { let i; let n; const o = {}; return r && (e && An(e) ? (n = e, e = function () { return Rn(n) }) : En(e) || (e = Bt(e)), ot(r, function (n, t) { i = e ? e.call(u, n, t, r) : n, o[i] ? o[i].push(n) : o[i] = [n] })), o } function ht (n, t, r) { return n(t, r ? function (n) { return pt(n, r) } : function (n) { return n }) } function pt (n, t) { return jn(n) ? ht(K, n, t) : wn(n) ? ht(sn, n, t) : n } function gt (n, t) { return n ? pt(n, t) : n } function vt (r, e, n) { if (r) { let t; const u = arguments.length > 1 && (Zn(e) || !An(e)); const i = u ? n : e; if (jn(r))_(r, u ? function (n, t) { r[t] = e } : function (n, t) { g(r, t) }), i && B(r, i); else if (wn(r)) { if (u) for (t = r.length; t > 0;)r[--t] = e; else r.length = 0; i && r.push.apply(r, i) } } return r } function dt (r, e, u) { if (r) { if (On(e)) return vt(r); const i = []; let o = []; return En(e) || (a = e, e = function (n, t) { return t === a }), ot(r, function (n, t, r) { e.call(u, n, t, r) && i.push(t) }), wn(r) ? at(i, function (n, t) { o.push(r[n]), r.splice(n, 1) }) : (o = {}, mn(i, function (n) { o[n] = r[n], g(r, n) })), o } let a; return r } function mt (n, t) { return t <= n ? n : (n >>= 0) + Math.round(Math.random() * ((t || 9) - n)) } const yt = c(function (n, t) { return t < n }); var St = c(function (n, t) { return n < t }); var bt = s(parseFloat); const Dt = s($); function xt (n, t) { const r = bt(n); const e = bt(t); const u = T(r); const i = T(e); return parseInt(u.replace('.', '')) * parseInt(i.replace('.', '')) / Math.pow(10, E(u) + E(i)) } function Mt (n, t, r) { let e = 0; return ot(n, t ? En(t) ? function () { e = k(e, t.apply(r, arguments)) } : function (n) { e = k(e, ft(n, t)) } : function (n) { e = k(e, n) }), e } const Ot = Date.now || function () { return y(w()) }; const Nt = [{ rules: [['yyyy', 4]] }, { rules: [['MM', 2], ['M', 1]], offset: -1 }, { rules: [['dd', 2], ['d', 1]] }, { rules: [['HH', 2], ['H', 1]] }, { rules: [['mm', 2], ['m', 1]] }, { rules: [['ss', 2], ['s', 1]] }, { rules: [['SSS', 3], ['S', 1]] }, { rules: [['ZZ', 5], ['Z', 6], ['Z', 5], ['Z', 1]] }]; function wt (n, t) { let r, e; if (n) if ((e = Cn(n)) || !t && /^[0-9]{11,15}$/.test(n))r = new Date(e ? y(n) : $(n)); else if (Tn(n)) { let u; const i = (function (n, t) { let r; let e; let u; let i; let o; let a; let f; let c; let l; const s = [0, 0, 1, 0, 0, 0, 0]; for (u = 0, i = Nt.length; u < i; u++) for (f = 0, c = (a = (o = Nt[u]).rules).length; f < c; f++) { if (r = a[f], (e = t.indexOf(r[0])) > -1 && (l = n.substring(e, e + r[1])) && l.length === r[1]) { o.offset && (l = $(l) + o.offset), s[u] = l; break } if (f === c - 1) return s } return s }(n, t || S.formatDate)); const o = i[7]; i[0] && (o ? o[0] === 'z' || o[0] === 'Z' ? r = new Date(O(i)) : (u = o.match(/([-+]{1})(\d{2}):?(\d{2})/)) && (r = new Date(O(i) - (u[1] === '-' ? -1 : 1) * $(u[2]) * 36e5 + 6e4 * $(u[3]))) : r = new Date(i[0], i[1], i[2], i[3], i[4], i[5], i[6])) } return !r || isNaN(y(r)) ? 'Invalid Date' : r } function kt (n, t, r, e) { const u = t[r]; return u ? En(u) ? u(e, r, n) : u[e] : e } const Et = /\[([^\]]+)]|y{2,4}|M{1,2}|d{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|Z{1,2}|W{1,2}|D{1,3}|[aAeEq]/g; function Ft (e, n, t) { if (e) { if (e = wt(e), Cn(e)) { const r = n || S.formatString; const u = e.getHours(); const i = u < 12 ? 'am' : 'pm'; const o = B({}, S.formatStringMatchs, t ? t.formats : null); const a = function (n, t) { return ('' + b(e)).substr(4 - t) }; const f = function (n, t) { return Ut(D(e) + 1, t, '0') }; const c = function (n, t) { return Ut(e.getDate(), t, '0') }; const l = function (n, t) { return Ut(u, t, '0') }; const s = function (n, t) { return Ut(u <= 12 ? u : u - 12, t, '0') }; const h = function (n, t) { return Ut(e.getMinutes(), t, '0') }; const p = function (n, t) { return Ut(e.getSeconds(), t, '0') }; const g = function (n, t) { return Ut(e.getMilliseconds(), t, '0') }; const v = function (n, t) { const r = e.getTimezoneOffset() / 60 * -1; return kt(e, o, n, (r >= 0 ? '+' : '-') + Ut(r, 2, '0') + (t === 1 ? ':' : '') + '00') }; const d = function (n, t) { return Ut(kt(e, o, n, Ct(e)), t, '0') }; const m = function (n, t) { return Ut(kt(e, o, n, jt(e)), t, '0') }; const y = { yyyy: a, yy: a, MM: f, M: f, dd: c, d: c, HH: l, H: l, hh: s, h: s, mm: h, m: h, ss: p, s: p, SSS: g, S: g, ZZ: v, Z: v, WW: d, W: d, DDD: m, D: m, a: function (n) { return kt(e, o, n, i) }, A: function (n) { return kt(e, o, n, i.toLocaleUpperCase()) }, e: function (n) { return kt(e, o, n, e.getDay()) }, E: function (n) { return kt(e, o, n, (t = e.getDay()) === 0 ? 7 : t); let t }, q: function (n) { return kt(e, o, n, Math.floor((D(e) + 3) / 3)) } }; return r.replace(Et, function (n, t) { return t || (y[n] ? y[n](n, n.length) : n) }) } return e } return '' } function Tt (n, t, r) { let e; if (n = wt(n), Cn(n) && (t && (e = t && !isNaN(t) ? t : 0, n.setFullYear(b(n) + e)), r || !isNaN(r))) { if (r === A) return new Date(b(n), 0, 1); if (r === I) return n.setMonth(11), Wt(n, 0, I); n.setMonth(r) } return n } function Wt (n, t, r) { const e = t && !isNaN(t) ? t : 0; if (n = wt(n), Cn(n)) { if (r || !isNaN(r)) { if (r === A) return new Date(b(n), D(n) + e, 1); if (r === I) return new Date(y(Wt(n, e + 1, A)) - 1); n.setDate(r) }e && n.setMonth(D(n) + e) } return n } function It (n, t, r) { let e, u, i; return n = wt(n), Cn(n) ? (i = $(/^[0-7]$/.test(r) ? r : n.getDay()), u = n.getDay(), e = y(n) + ((i === 0 ? 7 : i) - (u === 0 ? 7 : u)) * j, t && !isNaN(t) && (e += t * C), new Date(e)) : n } function At (n, t, r) { if (n = wt(n), Cn(n) && !isNaN(t)) { if (n.setDate(n.getDate() + $(t)), r === A) return new Date(b(n), D(n), n.getDate()); if (r === I) return new Date(y(At(n, 1, A)) - 1) } return n } function jt (n) { return n = wt(n), Cn(n) ? Math.floor((N(n) - N(Tt(n, 0, A))) / j) + 1 : n } function Ct (n) { if (n = wt(n), Cn(n)) { n.setHours(0, 0, 0, 0), n.setDate(n.getDate() + 3 - (n.getDay() + 6) % 7); const t = new Date(n.getFullYear(), 0, 4); return Math.round(((n.getTime() - t.getTime()) / j + (t.getDay() + 6) % 7 - 3) / 7) + 1 } return n } function Ht (n) { return n && n.trim ? n.trim() : Zt(Rt(n)) } function Rt (n) { return n && n.trimLeft ? n.trimLeft() : qt(n).replace(/^[\s\uFEFF\xA0]+/g, '') } function Zt (n) { return n && n.trimRight ? n.trimRight() : qt(n).replace(/[\s\uFEFF\xA0]+$/g, '') } const zt = m(P); const Lt = {}; ot(P, function (n, t) { Lt[P[t]] = t }); const $t = m(Lt); function Pt (n, t) { const r = qt(n); if (r.repeat) return r.repeat(t); const e = isNaN(t) ? [] : new Array($(t)); return e.join(r) + (e.length > 0 ? r : '') } function Ut (n, t, r) { const e = qt(n); return t >>= 0, r = Nn(r) ? ' ' : '' + r, e.padStart ? e.padStart(t, r) : t > e.length ? ((t -= e.length) > r.length && (r += Pt(r, t / r.length)), r.slice(0, t) + e) : e } function Yt (n, t, r) { const e = qt(n); return t >>= 0, r = Nn(r) ? ' ' : '' + r, e.padEnd ? e.padEnd(t, r) : t > e.length ? ((t -= e.length) > r.length && (r += Pt(r, t / r.length)), e + r.slice(0, t)) : e } function qt (n) { return Wn(n) ? T(n) : '' + (On(n) ? '' : n) } function Bt (t, r) { return function (n) { return Zn(n) ? r : n[t] } } function Jt (n) { return _t(n.split('?')[1] || '') } function Kt (n) { let t; let e; let r; let u; let i = '' + n; return i.indexOf('//') === 0 ? i = (H ? H.protocol : '') + i : i.indexOf('/') === 0 && (i = M() + i), r = i.replace(/#.*/, '').match(/(\?.*)/), (u = { href: i, hash: '', host: '', hostname: '', protocol: '', port: '', search: r && r[1] && r[1].length > 1 ? r[1] : '' }).path = i.replace(/^([a-z0-9.+-]*:)\/\//, function (n, t) { return u.protocol = t, '' }).replace(/^([a-z0-9.+-]*)(:\d+)?\/?/, function (n, t, r) { return e = r || '', u.port = e.replace(':', ''), u.hostname = t, u.host = t + e, '/' }).replace(/(#.*)/, function (n, t) { return u.hash = t.length > 1 ? t : '', '' }), t = u.hash.match(/#((.*)\?|(.*))/), u.pathname = u.path.replace(/(\?|#.*).*/, ''), u.origin = u.protocol + '//' + u.host, u.hashKey = t && (t[2] || t[1]) || '', u.hashQuery = Jt(u.hash), u.searchQuery = Jt(u.search), u } function _t (n) { let t; const r = {}; return n && Tn(n) && mn(n.split('&'), function (n) { t = n.split('='), r[L(t[0])] = L(t[1] || '') }), r } function Qt (n) { try { return n.setItem('__xe_t', 1), n.removeItem('__xe_t'), !0 } catch (n) { return !1 } } function Xt (n) { return navigator.userAgent.indexOf(n) > -1 } function Gt (n, t) { const r = parseFloat(t); const e = w(); const u = y(e); switch (n) { case 'y':return y(Tt(e, r)); case 'M':return y(Wt(e, r)); case 'd':return y(At(e, r)); case 'h':case 'H':return u + 60 * r * 60 * 1e3; case 'm':return u + 60 * r * 1e3; case 's':return u + 1e3 * r } return u } function Vt (n) { return (Cn(n) ? n : new Date(n)).toUTCString() } function nr (n, t, r) { if (Z) { let e; let u; let i; let o; let a; let f; let c = []; const l = arguments; return wn(n) ? c = n : l.length > 1 ? c = [B({ name: n, value: t }, r)] : An(n) && (c = [n]), c.length > 0 ? (mn(c, function (n) { e = B({}, S.cookies, n), i = [], e.name && (u = e.expires, i.push(z(e.name) + '=' + z(An(e.value) ? JSON.stringify(e.value) : e.value)), u && (u = isNaN(u) ? u.replace(/^([0-9]+)(y|M|d|H|h|m|s)$/, function (n, t, r) { return Vt(Gt(r, t)) }) : /^[0-9]{11,13}$/.test(u) || Cn(u) ? Vt(u) : Vt(Gt('d', u)), e.expires = u), mn(['expires', 'path', 'domain', 'secure'], function (n) { Nn(e[n]) || i.push(e[n] && n === 'secure' ? n : n + '=' + e[n]) })), Z.cookie = i.join('; ') }), !0) : (o = {}, (a = Z.cookie) && mn(a.split('; '), function (n) { f = n.indexOf('='), o[L(n.substring(0, f))] = L(n.substring(f + 1) || '') }), l.length === 1 ? o[n] : o) } return !1 } function tr (n, t, r) { return nr(n, t, r), nr } function rr (n, t) { nr(n, 0, B({ expires: -1 }, S.cookies, t)) } function er () { return tt(nr()) } return B(nr, { isKey: function (n) { return fn(er(), n) }, set: tr, setItem: tr, get: nr, getItem: nr, remove: rr, removeItem: rr, keys: er, getJSON: nr }), B(r, { assign: B, extend: J, objectEach: _, lastObjectEach: Q, objectMap: K, uniq: X, union: function () { for (var n = arguments, t = [], r = 0, e = n.length; r < e; r++)t = t.concat(pn(n[r])); return X(t) }, sortBy: nn, shuffle: tn, sample: function (n, t) { const r = tn(n); return arguments.length <= 1 ? r[0] : (t < r.length && (r.length = t || 0), r) }, some: rn, every: en, slice: un, filter: function (r, e, u) { const i = []; if (r && e) { if (r.filter) return r.filter(e, u); ot(r, function (n, t) { e.call(u, n, t, r) && i.push(n) }) } return i }, find: on, findKey: an, includes: fn, arrayIndexOf: cn, arrayLastIndexOf: ln, map: sn, reduce: function (n, t, r) { if (n) { let e; let u; let i = 0; let o = r; const a = arguments.length > 2; const f = tt(n); if (n.length && n.reduce) return u = function () { return t.apply(null, arguments) }, a ? n.reduce(u, o) : n.reduce(u); for (a && (i = 1, o = n[f[0]]), e = f.length; i < e; i++)o = t.call(null, o, n[f[i]], i, n); return o } }, copyWithin: function (n, t, r, e) { if (wn(n) && n.copyWithin) return n.copyWithin(t, r, e); let u; let i; let o = t >> 0; let a = r >> 0; const f = n.length; let c = arguments.length > 3 ? e >> 0 : f; if (o < f && (o = o >= 0 ? o : f + o) >= 0 && (a = a >= 0 ? a : f + a) < (c = c >= 0 ? c : f + c)) for (u = 0, i = n.slice(a, c); o < f && !(i.length <= u); o++)n[o] = i[u++]; return n }, chunk: function (n, t) { let r; let e = []; const u = t >> 0 || 1; if (wn(n)) if (u >= 0 && n.length > u) for (r = 0; r < n.length;)e.push(n.slice(r, r + u)), r += u; else e = n.length ? [n] : n; return e }, zip: function () { return hn(arguments) }, unzip: hn, zipObject: function (n, r) { const e = {}; return r = r || [], ot(rt(n), function (n, t) { e[n] = r[t] }), e }, flatten: function (n, t) { return wn(n) ? (function t (n, r) { let e = []; return mn(n, function (n) { e = e.concat(wn(n) ? r ? t(n, r) : n : [n]) }), e }(n, t)) : [] }, toArray: pn, includeArrays: gn, pluck: function (n, t) { return sn(n, t) }, invoke: vn, invokeMap: dn, arrayEach: mn, lastArrayEach: yn, toArrayTree: function (n, t) { let r; let e; let u; let i; let o; const a = B({}, S.treeOptions, t); const f = a.strict; const c = a.key; const l = a.parentKey; const s = a.children; const h = a.sortKey; const p = a.reverse; const g = a.data; const v = []; const d = {}; return h && (n = nn(gt(n), h), p && (n = n.reverse())), r = sn(n, function (n) { return n[c] }), ot(n, function (n) { e = n[c], g ? (u = {})[g] = n : u = n, i = n[l], d[e] = d[e] || [], d[i] = d[i] || [], d[i].push(u), u[c] = e, u[l] = i, u[s] = d[e], (!f || f && !i) && (fn(r, i) || v.push(u)) }), f && (o = s, ot(n, function (n) { n.children && !n.children.length && dt(n, o) })), v }, toTreeArray: function (n, t) { return (function t (r, n, e) { let u; const i = e.children; const o = e.data; return ot(n, function (n) { u = n[i], o && (n = n[o]), r.push(n), u && t(r, u, e) }), r }([], n, B({}, S.treeOptions, t))) }, findTree: Sn, eachTree: bn, mapTree: Dn, filterTree: function (n, o, t, a) { const f = []; return n && o && bn(n, function (n, t, r, e, u, i) { o.call(a, n, t, r, e, u, i) && f.push(n) }, t), f }, searchTree: xn, hasOwnProp: Mn, eqNull: On, isNaN: function (n) { return Wn(n) && isNaN(n) }, isFinite: function (n) { return Wn(n) && isFinite(n) }, isUndefined: Nn, isArray: wn, isFloat: function (n) { return !(Zn(n) || isNaN(n) || wn(n) || kn(n)) }, isInteger: kn, isFunction: En, isBoolean: Fn, isString: Tn, isNumber: Wn, isRegExp: In, isObject: An, isPlainObject: jn, isDate: Cn, isError: Hn, isTypeError: function (n) { return !!n && n.constructor === TypeError }, isEmpty: Rn, isNull: Zn, isSymbol: Ln, isArguments: $n, isElement: function (n) { return !!(n && Tn(n.nodeName) && Wn(n.nodeType)) }, isDocument: function (n) { return !(!n || !Z || n.nodeType !== 9) }, isWindow: function (n) { return R && !(!n || n !== n.window) }, isFormData: function (n) { return Pn && n instanceof FormData }, isMap: function (n) { return Un && n instanceof Map }, isWeakMap: function (n) { return Yn && n instanceof WeakMap }, isSet: function (n) { return qn && n instanceof Set }, isWeakSet: function (n) { return Bn && n instanceof WeakSet }, isLeapYear: Jn, isMatch: function (r, e) { const n = tt(r); const t = tt(e); return !t.length || (gn(n, t) ? rn(t, function (t) { return Vn(n, function (n) { return n === t && Kn(r[n], e[t]) }) > -1 }) : Kn(r, e)) }, isEqual: Kn, isEqualWith: function (n, t, o) { return En(o) ? v(n, t, function (n, t, r, e, u) { const i = o(n, t, r, e, u); return Nn(i) ? p(n, t) : !!i }, o) : v(n, t, p) }, getType: function (n) { return Zn(n) ? 'null' : Ln(n) ? 'symbol' : Cn(n) ? 'date' : wn(n) ? 'array' : In(n) ? 'regexp' : Hn(n) ? 'error' : typeof n }, uniqueId: function (n) { return [n, ++_n].join('') }, getSize: Qn, indexOf: Xn, lastIndexOf: Gn, findIndexOf: Vn, findLastIndexOf: nt, toStringJSON: function (n) { if (An(n)) return n; if (Tn(n)) try { return JSON.parse(n) } catch (n) {} return {} }, toJSONString: function (n) { return JSON.stringify(n) || '' }, keys: tt, values: rt, entries: et, pick: ut, omit: it, first: function (n) { return rt(n)[0] }, last: function (n) { const t = rt(n); return t[t.length - 1] }, each: ot, forOf: function (n, t, r) { if (n) if (wn(n)) for (let e = 0, u = n.length; e < u && !1 !== t.call(r, n[e], e, n); e++);else for (const i in n) if (Mn(n, i) && !1 === t.call(r, n[i], i, n)) break }, lastForOf: function (n, t, r) { let e, u; if (n) if (wn(n)) for (e = n.length - 1; e >= 0 && !1 !== t.call(r, n[e], e, n); e--);else for (e = (u = tt(n)).length - 1; e >= 0 && !1 !== t.call(r, n[u[e]], u[e], n); e--); }, lastEach: at, has: function (n, t) { if (n) { if (Mn(n, t)) return !0; let r; let e; let u; let i; let o; let a; const f = x(t); let c = 0; const l = f.length; for (o = n; c < l && (a = !1, (i = (r = f[c]) ? r.match(U) : '') ? (e = i[1], u = i[2], e ? o[e] && Mn(o[e], u) && (a = !0, o = o[e][u]) : Mn(o, u) && (a = !0, o = o[u])) : Mn(o, r) && (a = !0, o = o[r]), a); c++) if (c === l - 1) return !0 } return !1 }, get: ft, set: function (n, t, r) { if (n) if (n[t] || Mn(n, t))n[t] = r; else for (let e = n, u = x(t), i = u.length, o = 0; o < i; o++)e = lt(e, u[o], o === i - 1, r); return n }, groupBy: st, countBy: function (n, t, r) { const e = st(n, t, r || this); return _(e, function (n, t) { e[t] = n.length }), e }, clone: gt, clear: vt, remove: dt, range: function (n, t, r) { let e; let u; const i = []; const o = arguments; if (o.length < 2 && (t = o[0], n = 0), u = t >> 0, (e = n >> 0) < t) for (r = r >> 0 || 1; e < u; e += r)i.push(e); return i }, destructuring: function (t, n) { if (t && n) { const r = B.apply(this, [{}].concat(un(arguments, 1))); const e = tt(r); mn(tt(t), function (n) { fn(e, n) && (t[n] = r[n]) }) } return t }, random: mt, min: yt, max: St, commafy: function (n, t) { if (n = qt(n).replace(/,/g, '')) { const r = B({ spaceNumber: 3, separator: ',' }, t); const e = r.digits || r.fixed; const u = (e ? bt(n).toFixed(e) : n).split('.'); return u[0].replace(new RegExp('(?=(?!(\\b))(\\d{' + r.spaceNumber + '})+$)', 'g'), r.separator) + (u[1] ? '.' + u[1] : '') } return n }, toFixedString: function (n, t) { const r = d(n, t).split('.'); const e = t ? [r[0], '.', Yt(r[1] || '', t, '0')].join('') : r[0]; return e.substring(0, 1) === '-' && parseFloat(e) === 0 ? t ? e.replace(/^-/, '') : '0' : e }, toFixedNumber: function (n, t) { const r = (t ? bt : Dt)(d(n, t)); return r === 0 ? 0 : r }, toNumber: bt, toInteger: Dt, add: function (n, t) { return k(bt(n), bt(t)) }, subtract: function (n, t) { const r = bt(n); const e = bt(t); const u = T(r); const i = T(e); const o = E(u); const a = E(i); const f = Math.pow(10, Math.max(o, a)); return parseFloat(((r * f - e * f) / f).toFixed(a <= o ? o : a)) }, multiply: xt, divide: function (n, t) { return F(bt(n), bt(t)) }, sum: Mt, mean: function (n, t, r) { return F(Mt(n, t, r), Qn(n)) }, now: Ot, timestamp: function (n, t) { if (n) { const r = wt(n, t); return Cn(r) ? y(r) : r } return Ot() }, isDateSame: function (n, t, r) { return !(!n || !t) && (n = Ft(n, r)) !== 'Invalid Date' && n === Ft(t, r) }, toStringDate: wt, toDateString: Ft, getWhatYear: Tt, getWhatMonth: Wt, getWhatWeek: It, getWhatDay: At, getYearDay: jt, getYearWeek: Ct, getMonthWeek: function n (t) { let r; let e; const u = wt(t); return Cn(u) ? ((e = It(r = Wt(u, 0, A), 0, 1)) < r && (e = It(r, 1, 1)), e <= u ? Math.floor((N(u) - N(e)) / C) + 1 : n(It(u, 0, 1))) : u }, getDayOfYear: function (n, t) { return n = wt(n), Cn(n) ? Jn(Tt(n, t)) ? 366 : 365 : n }, getDayOfMonth: function (n, t) { return n = wt(n), Cn(n) ? Math.floor((y(Wt(n, t, I)) - y(Wt(n, t, A))) / j) + 1 : n }, getDateDiff: function (n, t, r) { let e; let u; let i; let o; let a; let f; let c; const l = { done: !1, time: 0 }; if (n = wt(n), t = t ? wt(t) : w(), Cn(n) && Cn(t) && (e = y(n)) < (u = y(t))) for (o = l.time = u - e, a = r && r.length > 0 ? r : S.dateDiffRules, l.done = !0, c = 0, f = a.length; c < f; c++)o >= (i = a[c])[1] ? c === f - 1 ? l[i[0]] = o || 0 : (l[i[0]] = Math.floor(o / i[1]), o -= l[i[0]] * i[1]) : l[i[0]] = 0; return l }, trim: Ht, trimLeft: Rt, trimRight: Zt, escape: zt, unescape: $t, camelCase: function (n) { return qt(n).replace(/(-[a-zA-Z])/g, function (n, t) { return t.substring(1).toLocaleUpperCase() }) }, kebabCase: function (n) { return qt(n).replace(/([A-Z])/g, function (n, t) { return '-' + t.toLowerCase() }) }, repeat: Pt, padStart: Ut, padEnd: Yt, startsWith: function (n, t, r) { const e = qt(n); return (arguments.length === 1 ? e : e.substring(r)).indexOf(t) === 0 }, endsWith: function (n, t, r) { const e = qt(n); const u = arguments.length; return u > 1 && (u > 2 ? e.substring(0, r).indexOf(t) === r - 1 : e.indexOf(t) === e.length - 1) }, template: function (n, r) { return qt(n).replace(/\{{2}([.\w[\]\s]+)\}{2}/g, function (n, t) { return ft(r, Ht(t)) }) }, toString: qt, property: Bt, bind: function (n, t) { const r = un(arguments, 2); return function () { return n.apply(t, un(arguments).concat(r)) } }, once: function (n, t) { let r = !1; let e = null; const u = un(arguments, 2); return function () { return r || (e = n.apply(t, un(arguments).concat(u)), r = !0), e } }, after: function (t, r, e) { let u = 0; const i = []; return function () { const n = arguments; ++u <= t && i.push(n[0]), t <= u && r.apply(e, [i].concat(un(n))) } }, before: function (t, r, e) { let u = 0; const i = []; return e = e || this, function () { const n = arguments; ++u < t && (i.push(n[0]), r.apply(e, [i].concat(un(n)))) } }, throttle: function (n, t, r) { let e; let u; const i = r || {}; let o = !1; let a = 0; const f = !('leading' in i) || i.leading; const c = 'trailing' in i && i.trailing; const l = function () { o = !0, n.apply(u, e), a = setTimeout(s, t) }; var s = function () { a = 0, o || !0 !== c || l() }; const h = function () { e = arguments, u = this, o = !1, a === 0 && (!0 === f ? l() : !0 === c && (a = setTimeout(s, t))) }; return h.cancel = function () { const n = a !== 0; return clearTimeout(a), o = !1, a = 0, n }, h }, debounce: function (n, t, r) { let e; let u; const i = r || {}; let o = !1; let a = 0; const f = typeof r === 'boolean'; const c = 'leading' in i ? i.leading : f; const l = 'trailing' in i ? i.trailing : !f; const s = function () { o = !0, a = 0, n.apply(u, e) }; const h = function () { !0 === c && (a = 0), o || !0 !== l || s() }; const p = function () { o = !1, e = arguments, u = this, a === 0 ? !0 === c && s() : clearTimeout(a), a = setTimeout(h, t) }; return p.cancel = function () { const n = a !== 0; return clearTimeout(a), a = 0, n }, p }, delay: function (n, t) { const r = un(arguments, 2); const e = this; return setTimeout(function () { n.apply(e, r) }, t) }, unserialize: _t, serialize: function (n) { let r; let e = []; return ot(n, function (n, t) { Nn(n) || (r = wn(n), jn(n) || r ? e = e.concat(function r (n, e, u) { let i; let o = []; return ot(n, function (n, t) { i = wn(n), jn(n) || i ? o = o.concat(r(n, e + '[' + t + ']', i)) : o.push(z(e + '[' + (u ? '' : t) + ']') + '=' + z(Zn(n) ? '' : n)) }), o }(n, t, r)) : e.push(z(t) + '=' + z(Zn(n) ? '' : n))) }), e.join('&').replace(/%20/g, '+') }, parseUrl: Kt, getBaseURL: function () { if (H) { const n = H.pathname; const t = Gn(n, '/') + 1; return M() + (t === n.length ? n : n.substring(0, t)) } return '' }, locat: function () { return H ? Kt(H.href) : {} }, browse: function () { let t; let n; let r; let e = !1; const u = { isNode: !1, isMobile: e, isPC: !1, isDoc: !!Z }; return R || typeof process === W ? (r = Xt('Edge'), n = Xt('Chrome'), e = /(Android|webOS|iPhone|iPad|iPod|SymbianOS|BlackBerry|Windows Phone)/.test(navigator.userAgent), u.isDoc && (t = Z.body || Z.documentElement, mn(['webkit', 'khtml', 'moz', 'ms', 'o'], function (n) { u['-' + n] = !!t[n + 'MatchesSelector'] })), B(u, { edge: r, firefox: Xt('Firefox'), msie: !r && u['-ms'], safari: !n && !r && Xt('Safari'), isMobile: e, isPC: !e, isLocalStorage: Qt(R.localStorage), isSessionStorage: Qt(R.sessionStorage) })) : u.isNode = !0, u }, cookie: nr }), r }))
